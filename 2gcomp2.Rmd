# G-computation using ML

```{r setup01, include=FALSE}
require(knitr)
require(glmnet)
require(kableExtra)
require(dplyr)
require(xgboost)
require(SuperLearner)
options(knitr.kable.NA = '')
cachex=TRUE
```

- G-computation is highly sensitive to on **model misspecification**; and when model is not correctly specified, result is subject to bias. 
- Therefore, it can be a good idea to use **machine learning** methods, that are more flexible, than parametric methods to estimate the treatment effect.
- Although ML methods are powerful in point estimation, the coverage probabilities are usually poor when more flexible methods are used, if inference is one of the goals. Hence we are focusing on **point estimation** here.

## G-comp using Regression tree

```{r reg2sl, cache=cachex, echo = TRUE}
# Read the data saved at the last chapter
ObsData <- readRDS(file = "data/rhcAnalytic.RDS")
```

### A tree based algorithm

XGBoost is a fast version of gradient boosting algorithm. Let us use this one to fit the data first. We follow the exact same procedure that we followed in the parametric G-computation setting.

```{r ML1, cache=cachex, echo = TRUE}
require(xgboost)
Y <-ObsData$Y
ObsData.matrix <- model.matrix(out.formula, data = ObsData)
fit3 <- xgboost(data = ObsData.matrix, 
                label = Y,
                max.depth = 10, 
                eta = 1, 
                nthread = 15, 
                nrounds = 100, 
                alpha = 0.5,
                objective = "reg:squarederror", 
                verbose = 0)
```


### Extract outcome prediction as if everyone is treated

```{r ML12, cache=cachex, echo = TRUE}
ObsData.matrix.A1 <- ObsData.matrix 
ObsData.matrix.A1[,"A"] <- 1
ObsData$Pred.Y1 <- predict(fit3, newdata = ObsData.matrix.A1)
summary(ObsData$Pred.Y1)
```

### Extract outcome prediction as if everyone is untreated


```{r ML13, cache=cachex, echo = TRUE}
ObsData.matrix.A0 <- ObsData.matrix
ObsData.matrix.A0[,"A"] <- 0
ObsData$Pred.Y0 <- predict(fit3, newdata = ObsData.matrix.A0)
summary(ObsData$Pred.Y0)
```

### Treatment effect estimate


```{r ML13b, cache=cachex, echo = TRUE}
ObsData$Pred.TE <- ObsData$Pred.Y1 - ObsData$Pred.Y0  

```


Mean value of predicted treatment effect 

```{r reg2acnx1b, cache=cachex, echo = TRUE}
summary(ObsData$Pred.TE)
```

Notice that the mean is slightly different than the parametric G-computation method.

## G-comp using regularized methods

### A regularized model

LASSO is a regularized method. One of the use of these methods is variable selection. Let us use this method to fit our data.

```{r ML1r, cache=cachex, echo = TRUE}
require(glmnet)
Y <-ObsData$Y
ObsData.matrix <- model.matrix(out.formula, data = ObsData)
fit4 <-  cv.glmnet(x = ObsData.matrix, 
                y = Y,
                alpha = 0.5,
                relax=TRUE)
```


### Extract outcome prediction as if everyone is treated

```{r ML12r, cache=cachex, echo = TRUE}
ObsData.matrix.A1 <- ObsData.matrix 
ObsData.matrix.A1[,"A"] <- 1
ObsData$Pred.Y1 <- predict(fit4, newx = ObsData.matrix.A1,
                           s = "lambda.min")
summary(ObsData$Pred.Y1)
```

### Extract outcome prediction as if everyone is untreated


```{r ML13r, cache=cachex, echo = TRUE}
ObsData.matrix.A0 <- ObsData.matrix
ObsData.matrix.A0[,"A"] <- 0
ObsData$Pred.Y0 <- predict(fit4, newx = ObsData.matrix.A0,
                           s = "lambda.min")
summary(ObsData$Pred.Y0)
```

### Treatment effect estimate


```{r ML13br, cache=cachex, echo = TRUE}
ObsData$Pred.TE <- ObsData$Pred.Y1 - ObsData$Pred.Y0  

```


Mean value of predicted treatment effect 

```{r reg2acnx1br, cache=cachex, echo = TRUE}
summary(ObsData$Pred.TE)
```

Notice that the mean is very similar to the parametric G-computation method.

## G-comp using SuperLearner

- SuperLearner is an ensemble MLtechnique, that uses **cross-validation** to find a weighted combination of estimates provided by different **candidate learners** (that help predict).
- There exists many candidate learners. Here we are using a combination of
  - linear regression
  - Regularized regression (lasso)
  - gradient boosting (tree based)
  
## Steps  

1. Screen variables


```{r role, echo = FALSE, out.width = "650px", fig.cap="Variable roles"}
knitr::include_graphics("images/role.png")
```

- Think about the role of variables first
  - ideally include confounders to reduce bias
  - consider including risk factor for outcome for greater accuracy
  - IV, collider, mediators should be avoided
  - if something is unmeasured, consider adding proxy (with causion)
- do pre-screening
    - sparse binary variables
    - highly collinear variables

2. Identify candidate learners

- Choose variety of candidate learners 
   - parametric (linear or logistic regression)
    - regularized (LASSO, ridge, elasticnet)
    - stepwise
   - non-parametric 
    - transformation (SVM, NN)
    - tree based (bagging, boosting)
   - smoothing or spline (gam)
- tune the candidate learners for better performance
  - tree depth
  - tune regularization parameters
  - variable selection
  
**SuperLearner** is an ensemble learning method. Let us use this one to fit the data first.

```{r ML1s, cache=cachex, echo = TRUE, results='hide', warning = FALSE}
require(SuperLearner)
ObsData.noY <- dplyr::select(ObsData, !Y)
fit.sl <- SuperLearner(Y=ObsData$Y, 
                       X=ObsData.noY, 
                       cvControl = list(V = 3),
                       SL.library=c("SL.glm", "SL.glmnet", "SL.xgboost"), 
                       family="gaussian")
```

3. SuperLearner first **splits** the data according to chosen $K$ fold for the cross-validation

```{r cvpic, echo = FALSE, out.width = "650px", fig.cap="Cross validation from [wiki](https://en.wikipedia.org/wiki/Cross-validation_(statistics)); training data = used for building model; test data = used for prediction from the model that was built using training data; each iteration = fold"}
knitr::include_graphics("images/CV.png")
```

- cross-validation is a core part of superlearner
  - select $K$ judiciously
    - large sample size means small $K$ may be adequate
      - for $n \lt 10,000$ consider $K=3$
      - for $n \lt 500$ consider $K=20$
    - smaller sample size means larger $K$ may be necessary
      - for $n \lt 30$ consider leave 1 out 

4. for each fold, it estimates a **measure of performance** (could be RMSE) in test sets based on models that was built using training sets

$RMSE = \sqrt{\frac{1}{n}\sum_{i=1}^n (Y - \hat{Y})^2}$ for continuous $Y$

Performance measures

5. Once we have the performance measures and predictions from candidate learners, we could go one of **two routes** here

  a. **Discrete SL**: measure of performance from all folds are averaged, and choose the **best** one. The prediction from the chosen learners are then used.

```{r ML12stestrisk, cache=cachex, echo = TRUE}
fit.sl$cvRisk
```

`glmnet` has the lowest cross-validated risk

```{r ML12stest, cache=cachex, echo = TRUE}
all.pred <- predict(fit.sl, type = "response")
head(all.pred$library.predict)
head(all.pred$library.predict[,"SL.glmnet_All"])
```  

  b. **Ensamble SL**: Alternatively, we fit a meta regression (can be a linear regression) of the following equation: $Y_{obs}$ $\sim$ $\hat{Y}_{SL.glm_{All}}$ + $\hat{Y}_{SL.glm_{All}}$ + $\hat{Y}_{SL.xgboost_{All}}$. 

```{r ML12stestx, cache=cachex, echo = TRUE}
head(all.pred$library.predict)
``` 
  
We estimate the regression coefs, scale them to 1, and the scaled coefficients represents the **value of the corresponding candidate learner**. A new prediction column is produced based on the fitted values from this meta regression.

scaled coefs

```{r ML12stestcoef, cache=cachex, echo = TRUE}
fit.sl$coef
```

Hence, in creating superlearner prediction column,

- Linear regression has no contribution
- lasso has majority contribution
- gradient boosting of tree has some minimal contribution

```{r ML12stestb, cache=cachex, echo = TRUE}
all.pred <- predict(fit.sl, type = "response")
pred.SL<-as.data.frame(cbind(all.pred$library.predict,
                             all.pred$pred))
names(pred.SL) <- c(names(pred.SL)[-4],"SL")
head(pred.SL)
```  

### Extract outcome prediction as if everyone is treated

```{r ML12s, cache=cachex, echo = TRUE}
ObsData.noY$A <- 1
ObsData$Pred.Y1 <- predict(fit.sl, newdata = ObsData.noY,
                           type = "response")$pred
summary(ObsData$Pred.Y1)
```

### Extract outcome prediction as if everyone is untreated


```{r ML13s, cache=cachex, echo = TRUE}
ObsData.noY$A <- 0
ObsData$Pred.Y0 <- predict(fit.sl, newdata = ObsData.noY,
                           type = "response")$pred
summary(ObsData$Pred.Y0)
```

### Treatment effect estimate


```{r ML13bs, cache=cachex, echo = TRUE}
ObsData$Pred.TE <- ObsData$Pred.Y1 - ObsData$Pred.Y0  

```


Mean value of predicted treatment effect 

```{r reg2acnx1bs, cache=cachex, echo = TRUE}
summary(ObsData$Pred.TE)
```

### Additional details for SL

- other similar algorithms such as cross-fitting had been shown to have better performances
- for rare outcomes, consider using stratification to attempt to maintain training and test sample ratios the same
- if data is clustered and not independent and identically distributed, use ID for the cluster
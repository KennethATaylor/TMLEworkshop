# G-computation using ML

```{r setup01, include=FALSE}
require(knitr)
require(glmnet)
require(kableExtra)
require(dplyr)
require(xgboost)
require(SuperLearner)
options(knitr.kable.NA = '')
cachex=TRUE
```

- G-computation is highly sensitive to on **model misspecification**; and when model is not correctly specified, result is subject to bias. 
- Therefore, it can be a good idea to use **machine learning** methods, that are more flexible, than parametric methods to estimate the treatment effect.
- Although ML methods are powerful in point estimation, the coverage probabilities are usually poor when more flexible methods are used, if inference is one of the goals. Hence we are focusing on **point estimation** here.

## G-comp using Regression tree

```{r reg2sl, cache=cachex, echo = TRUE}
# Read the data saved at the last chapter
ObsData <- readRDS(file = "data/rhcAnalytic.RDS")
baselinevars <- names(dplyr::select(ObsData, !c(A,Y)))
out.formula <- as.formula(paste("Y~ A +",
                               paste(baselinevars,
                                     collapse = "+")))
```

### A tree based algorithm

XGBoost is a fast version of gradient boosting algorithm. Let us use this one to fit the data first. We follow the exact same procedure that we followed in the parametric G-computation setting.

```{r ML1, cache=cachex, echo = TRUE}
require(xgboost)
Y <-ObsData$Y
ObsData.matrix <- model.matrix(out.formula, data = ObsData)
fit3 <- xgboost(data = ObsData.matrix, 
                label = Y,
                max.depth = 10, 
                eta = 1, 
                nthread = 15, 
                nrounds = 100, 
                alpha = 0.5,
                objective = "reg:squarederror", 
                verbose = 0)
```


### Extract outcome prediction as if everyone is treated

```{r ML12, cache=cachex, echo = TRUE}
ObsData.matrix.A1 <- ObsData.matrix 
ObsData.matrix.A1[,"A"] <- 1
ObsData$Pred.Y1 <- predict(fit3, newdata = ObsData.matrix.A1)
summary(ObsData$Pred.Y1)
```

### Extract outcome prediction as if everyone is untreated


```{r ML13, cache=cachex, echo = TRUE}
ObsData.matrix.A0 <- ObsData.matrix
ObsData.matrix.A0[,"A"] <- 0
ObsData$Pred.Y0 <- predict(fit3, newdata = ObsData.matrix.A0)
summary(ObsData$Pred.Y0)
```

### Treatment effect estimate


```{r ML13b, cache=cachex, echo = TRUE}
ObsData$Pred.TE <- ObsData$Pred.Y1 - ObsData$Pred.Y0  

```


Mean value of predicted treatment effect 

```{r reg2acnx1b, cache=cachex, echo = TRUE}
summary(ObsData$Pred.TE)
```

Notice that the mean is slightly different than the parametric G-computation method.

## G-comp using regularized methods

### A regularized model

LASSO is a regularized method. One of the use of these methods is variable selection. Let us use this method to fit our data.

```{r ML1r, cache=cachex, echo = TRUE}
require(glmnet)
Y <-ObsData$Y
ObsData.matrix <- model.matrix(out.formula, data = ObsData)
fit4 <-  cv.glmnet(x = ObsData.matrix, 
                y = Y,
                alpha = 0.5,
                relax=TRUE)
```


### Extract outcome prediction as if everyone is treated

```{r ML12r, cache=cachex, echo = TRUE}
ObsData.matrix.A1 <- ObsData.matrix 
ObsData.matrix.A1[,"A"] <- 1
ObsData$Pred.Y1 <- predict(fit4, newx = ObsData.matrix.A1,
                           s = "lambda.min")
summary(ObsData$Pred.Y1)
```

### Extract outcome prediction as if everyone is untreated


```{r ML13r, cache=cachex, echo = TRUE}
ObsData.matrix.A0 <- ObsData.matrix
ObsData.matrix.A0[,"A"] <- 0
ObsData$Pred.Y0 <- predict(fit4, newx = ObsData.matrix.A0,
                           s = "lambda.min")
summary(ObsData$Pred.Y0)
```

### Treatment effect estimate


```{r ML13br, cache=cachex, echo = TRUE}
ObsData$Pred.TE <- ObsData$Pred.Y1 - ObsData$Pred.Y0  

```


Mean value of predicted treatment effect 

```{r reg2acnx1br, cache=cachex, echo = TRUE}
summary(ObsData$Pred.TE)
```

Notice that the mean is very similar to the parametric G-computation method.

## G-comp using SuperLearner

- SuperLearner is an ensemble MLtechnique, that uses **cross-validation** to find a weighted combination of estimates provided by different **candidate learners** (that help predict).
- There exists many candidate learners. Here we are using a combination of
  - linear regression
  - Regularized regression (lasso)
  - gradient boosting (tree based)
  
### Steps  

1. **Identify candidate learners**

- Choose variety of candidate learners 
   - parametric (linear or logistic regression)
    - regularized (LASSO, ridge, elasticnet)
    - stepwise
   - non-parametric 
    - transformation (SVM, NN)
    - tree based (bagging, boosting)
   - smoothing or spline (gam)
- tune the candidate learners for better performance
  - tree depth
  - tune regularization parameters
  - variable selection
  
**SuperLearner** is an ensemble learning method. Let us use this one to fit the data first.

```{r ML1s, cache=cachex, echo = TRUE, results='hide', warning = FALSE}
require(SuperLearner)
ObsData.noY <- dplyr::select(ObsData, !Y)
fit.sl <- SuperLearner(Y=ObsData$Y, 
                       X=ObsData.noY, 
                       cvControl = list(V = 3),
                       SL.library=c("SL.glm", "SL.glmnet", "SL.xgboost"), 
                       method="method.NNLS",
                       family="gaussian")
```

2. **Cross-validation**:

To combat against optimism, we use cross-validation. SuperLearner first **splits** the data according to chosen $K$ fold for the cross-validation. That means

- fitting models in training data
- obtaining prediction in test data

```{r cvpic, echo = FALSE, out.width = "650px", fig.cap="Cross validation from [wiki](https://en.wikipedia.org/wiki/Cross-validation_(statistics)); training data = used for building model; test data = used for prediction from the model that was built using training data; each iteration = fold"}
knitr::include_graphics("images/CV.png")
```

- cross-validation is a core part of superlearner
  - select $K$ judiciously
    - large sample size means small $K$ may be adequate
      - for $n \lt 10,000$ consider $K=3$
      - for $n \lt 500$ consider $K=20$
    - smaller sample size means larger $K$ may be necessary
      - for $n \lt 30$ consider leave 1 out 

3. **Estimate risk**:

The goal is to minimize the estimated risk (i.e., minimize the difference of $Y$ and $\hat{Y}$) that comes out of a model. For each fold, estimate a **measure of performance** (could be RMSE) in test sets based on models that was built using training sets

$RMSE = \sqrt{\frac{1}{n}\sum_{i=1}^n (Y - \hat{Y})^2}$ for continuous $Y$

- we obtain risk estimate in each fold (from test data)
- we average all the estimates risks

```{r ML12stestrisk, cache=cachex, echo = TRUE}
fit.sl$cvRisk
```

4. **Find SL prediction**

Once we have the performance measures and predictions from candidate learners, we could go one of **two routes** here

  a. **Discrete SL**: measure of performance from all folds are averaged, and choose the **best** one. The prediction from the chosen learners are then used.

`glmnet` has the lowest cross-validated risk

```{r ML12stest, cache=cachex, echo = TRUE}
all.pred <- predict(fit.sl, type = "response")
Yhat <- all.pred$library.predict
head(Yhat)
as.matrix(head(Yhat[,"SL.glmnet_All"]), 
          ncol=1)
```  

  b. **Ensamble SL**: 

Here are the first 6 rows from the candidate learner predictions:

```{r ML12stestx, cache=cachex, echo = TRUE}
head(Yhat)
``` 
  
- fit a meta learner
  - linear regression (without intercept, but could produce -ve coefs) or 
  - preferably non-negative least squares for 
  
  $Y_{obs}$ $\sim$ $\hat{Y}_{SL.glm}$ + $\hat{Y}_{SL.glmnet}$ + $\hat{Y}_{SL.xgboost}$. 

- Obtain the regression coefs $\mathbf{\beta}$ = ($\beta_{SL.glm}$, $\beta_{SL.glmnet}$, $\beta_{SL.xgboost}$) for each $\hat{Y}$, 
- scale them to 1 
  - $\mathbf{\beta_{scaled}}$ = $\mathbf{\beta}$ / $\sum_{i=1}^3{\mathbf{\beta}}$; 
  - so that the  sum of scaled coefs =  1 
- Scaled coefficients $\mathbf{\beta_{scaled}}$ represents the **value / importance of the corresponding candidate learner**. 

Scaled coefs

```{r ML12stestcoef, cache=cachex, echo = TRUE}
fit.sl$coef
```

Hence, in creating superlearner prediction column,

a. Linear regression has no contribution
b. lasso has majority contribution
c. gradient boosting of tree has some minimal contribution

- A new prediction column is produced based on the fitted values from this meta regression.

You can simply multiply these coefs to the predictions from candidate learners, and them sum them to get ensable SL. Here are the first 6 values:

```{r ML12stestb0, cache=cachex, echo = TRUE}
SL.ens <- t(t(Yhat)*fit.sl$coef)
head(SL.ens)
as.matrix(head(rowSums(SL.ens)), ncol = 1)
```  

Alternatively, you can get them directly from the package: here are the first 6 values

```{r ML12stestb, cache=cachex, echo = TRUE}
head(all.pred$pred)
```  

The last column is coming from Ensamble SL.

### Extract outcome prediction as if everyone is treated

We are going to use **Ensamble SL** predictions in the following calculations. If you wanted to use discrete SL predictions instead, that would be fine too.

```{r ML12s, cache=cachex, echo = TRUE}
ObsData.noY$A <- 1
ObsData$Pred.Y1 <- predict(fit.sl, newdata = ObsData.noY,
                           type = "response")$pred
summary(ObsData$Pred.Y1)
```

### Extract outcome prediction as if everyone is untreated


```{r ML13s, cache=cachex, echo = TRUE}
ObsData.noY$A <- 0
ObsData$Pred.Y0 <- predict(fit.sl, newdata = ObsData.noY,
                           type = "response")$pred
summary(ObsData$Pred.Y0)
```

### Treatment effect estimate


```{r ML13bs, cache=cachex, echo = TRUE}
ObsData$Pred.TE <- ObsData$Pred.Y1 - ObsData$Pred.Y0  

```


Mean value of predicted treatment effect 

```{r reg2acnx1bs, cache=cachex, echo = TRUE}
summary(ObsData$Pred.TE)
```

### Additional details for SL

- other similar algorithms such as **cross-fitting** had been shown to have better performances
- for rare outcomes, consider using **stratification** to attempt to maintain training and test sample ratios the same
- if data is clustered and not independent and identically distributed, use ID for the **cluster**
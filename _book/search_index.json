[["g-computation-using-ml.html", "Chapter 3 G-computation using ML 3.1 G-comp using Regression tree 3.2 G-comp using regularized methods 3.3 G-comp using SuperLearner 3.4 Steps", " Chapter 3 G-computation using ML G-computation is highly sensitive to on model misspecification; and when model is not correctly specified, result is subject to bias. Therefore, it can be a good idea to use machine learning methods, that are more flexible, than parametric methods to estimate the treatment effect. Although ML methods are powerful in point estimation, the coverage probabilities are usually poor when more flexible methods are used, if inference is one of the goals. Hence we are focusing on point estimation here. 3.1 G-comp using Regression tree # Read the data saved at the last chapter ObsData &lt;- readRDS(file = &quot;data/rhcAnalytic.RDS&quot;) 3.1.1 A tree based algorithm XGBoost is a fast version of gradient boosting algorithm. Let us use this one to fit the data first. We follow the exact same procedure that we followed in the parametric G-computation setting. require(xgboost) Y &lt;-ObsData$Y ObsData.matrix &lt;- model.matrix(out.formula, data = ObsData) fit3 &lt;- xgboost(data = ObsData.matrix, label = Y, max.depth = 10, eta = 1, nthread = 15, nrounds = 100, alpha = 0.5, objective = &quot;reg:squarederror&quot;, verbose = 0) 3.1.2 Extract outcome prediction as if everyone is treated ObsData.matrix.A1 &lt;- ObsData.matrix ObsData.matrix.A1[,&quot;A&quot;] &lt;- 1 ObsData$Pred.Y1 &lt;- predict(fit3, newdata = ObsData.matrix.A1) summary(ObsData$Pred.Y1) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -24.061 7.997 15.990 23.417 29.978 393.987 3.1.3 Extract outcome prediction as if everyone is untreated ObsData.matrix.A0 &lt;- ObsData.matrix ObsData.matrix.A0[,&quot;A&quot;] &lt;- 0 ObsData$Pred.Y0 &lt;- predict(fit3, newdata = ObsData.matrix.A0) summary(ObsData$Pred.Y0) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -43.192 6.914 13.004 20.189 24.827 337.984 3.1.4 Treatment effect estimate ObsData$Pred.TE &lt;- ObsData$Pred.Y1 - ObsData$Pred.Y0 Mean value of predicted treatment effect summary(ObsData$Pred.TE) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -195.6580 -0.9165 0.7056 3.2275 7.5578 177.9588 Notice that the mean is slightly different than the parametric G-computation method. 3.2 G-comp using regularized methods 3.2.1 A regularized model LASSO is a regularized method. One of the use of these methods is variable selection. Let us use this method to fit our data. require(glmnet) Y &lt;-ObsData$Y ObsData.matrix &lt;- model.matrix(out.formula, data = ObsData) fit4 &lt;- cv.glmnet(x = ObsData.matrix, y = Y, alpha = 0.5, relax=TRUE) 3.2.2 Extract outcome prediction as if everyone is treated ObsData.matrix.A1 &lt;- ObsData.matrix ObsData.matrix.A1[,&quot;A&quot;] &lt;- 1 ObsData$Pred.Y1 &lt;- predict(fit4, newx = ObsData.matrix.A1, s = &quot;lambda.min&quot;) summary(ObsData$Pred.Y1) ## lambda.min ## Min. :-33.50 ## 1st Qu.: 19.31 ## Median : 24.03 ## Mean : 23.36 ## 3rd Qu.: 27.67 ## Max. : 39.89 3.2.3 Extract outcome prediction as if everyone is untreated ObsData.matrix.A0 &lt;- ObsData.matrix ObsData.matrix.A0[,&quot;A&quot;] &lt;- 0 ObsData$Pred.Y0 &lt;- predict(fit4, newx = ObsData.matrix.A0, s = &quot;lambda.min&quot;) summary(ObsData$Pred.Y0) ## lambda.min ## Min. :-36.41 ## 1st Qu.: 16.40 ## Median : 21.12 ## Mean : 20.45 ## 3rd Qu.: 24.75 ## Max. : 36.98 3.2.4 Treatment effect estimate ObsData$Pred.TE &lt;- ObsData$Pred.Y1 - ObsData$Pred.Y0 Mean value of predicted treatment effect summary(ObsData$Pred.TE) ## lambda.min ## Min. :2.913 ## 1st Qu.:2.913 ## Median :2.913 ## Mean :2.913 ## 3rd Qu.:2.913 ## Max. :2.913 Notice that the mean is very similar to the parametric G-computation method. 3.3 G-comp using SuperLearner SuperLearner is an ensemble MLtechnique, that uses cross-validation to find a weighted combination of estimates provided by different candidate learners (that help predict). There exists many candidate learners. Here we are using a combination of linear regression Regularized regression (lasso) gradient boosting (tree based) 3.4 Steps Screen variables Figure 3.1: Variable roles Think about the role of variables first ideally include confounders to reduce bias consider including risk factor for outcome for greater accuracy IV, collider, mediators should be avoided if something is unmeasured, consider adding proxy (with causion) do pre-screening sparse binary variables highly collinear variables Identify candidate learners Choose variety of candidate learners parametric (linear or logistic regression) regularized (LASSO, ridge, elasticnet) stepwise non-parametric transformation (SVM, NN) tree based (bagging, boosting) smoothing or spline (gam) tune the candidate learners for better performance tree depth tune regularization parameters variable selection SuperLearner is an ensemble learning method. Let us use this one to fit the data first. require(SuperLearner) ObsData.noY &lt;- dplyr::select(ObsData, !Y) fit.sl &lt;- SuperLearner(Y=ObsData$Y, X=ObsData.noY, cvControl = list(V = 3), SL.library=c(&quot;SL.glm&quot;, &quot;SL.glmnet&quot;, &quot;SL.xgboost&quot;), family=&quot;gaussian&quot;) SuperLearner first splits the data according to chosen \\(K\\) fold for the cross-validation Figure 3.2: Cross validation from wiki; training data = used for building model; test data = used for prediction from the model that was built using training data; each iteration = fold cross-validation is a core part of superlearner select \\(K\\) judiciously large sample size means small \\(K\\) may be adequate for \\(n \\lt 10,000\\) consider \\(K=3\\) for \\(n \\lt 500\\) consider \\(K=20\\) smaller sample size means larger \\(K\\) may be necessary for \\(n \\lt 30\\) consider leave 1 out for each fold, it estimates a measure of performance (could be RMSE) in test sets based on models that was built using training sets \\(RMSE = \\sqrt{\\frac{1}{n}\\sum_{i=1}^n (Y - \\hat{Y})^2}\\) for continuous \\(Y\\) Performance measures Once we have the performance measures and predictions from candidate learners, we could go one of two routes here Discrete SL: measure of performance from all folds are averaged, and choose the best one. The prediction from the chosen learners are then used. fit.sl$cvRisk ## SL.glm_All SL.glmnet_All SL.xgboost_All ## 635.3489 622.7141 734.8718 glmnet has the lowest cross-validated risk all.pred &lt;- predict(fit.sl, type = &quot;response&quot;) head(all.pred$library.predict) ## SL.glm_All SL.glmnet_All SL.xgboost_All ## 1 14.61647 14.50920 11.114755 ## 2 28.66305 28.67724 40.259663 ## 3 24.57800 24.77017 45.546345 ## 4 18.70422 19.03932 20.721554 ## 5 13.64956 12.17450 6.482043 ## 6 22.56895 21.78382 11.492613 head(all.pred$library.predict[,&quot;SL.glmnet_All&quot;]) ## 1 2 3 4 5 6 ## 14.50920 28.67724 24.77017 19.03932 12.17450 21.78382 Ensamble SL: Alternatively, we fit a meta regression (can be a linear regression) of the following equation: \\(Y_{obs}\\) \\(\\sim\\) \\(\\hat{Y}_{SL.glm_{All}}\\) + \\(\\hat{Y}_{SL.glm_{All}}\\) + \\(\\hat{Y}_{SL.xgboost_{All}}\\). head(all.pred$library.predict) ## SL.glm_All SL.glmnet_All SL.xgboost_All ## 1 14.61647 14.50920 11.114755 ## 2 28.66305 28.67724 40.259663 ## 3 24.57800 24.77017 45.546345 ## 4 18.70422 19.03932 20.721554 ## 5 13.64956 12.17450 6.482043 ## 6 22.56895 21.78382 11.492613 We estimate the regression coefs, scale them to 1, and the scaled coefficients represents the value of the corresponding candidate learner. A new prediction column is produced based on the fitted values from this meta regression. scaled coefs fit.sl$coef ## SL.glm_All SL.glmnet_All SL.xgboost_All ## 0.00000000 0.91846919 0.08153081 Hence, in creating superlearner prediction column, Linear regression has no contribution lasso has majority contribution gradient boosting of tree has some minimal contribution all.pred &lt;- predict(fit.sl, type = &quot;response&quot;) pred.SL&lt;-as.data.frame(cbind(all.pred$library.predict, all.pred$pred)) names(pred.SL) &lt;- c(names(pred.SL)[-4],&quot;SL&quot;) head(pred.SL) ## SL.glm_All SL.glmnet_All SL.xgboost_All SL ## 1 14.61647 14.50920 11.114755 14.23245 ## 2 28.66305 28.67724 40.259663 29.62156 ## 3 24.57800 24.77017 45.546345 26.46407 ## 4 18.70422 19.03932 20.721554 19.17647 ## 5 13.64956 12.17450 6.482043 11.71039 ## 6 22.56895 21.78382 11.492613 20.94477 3.4.1 Extract outcome prediction as if everyone is treated ObsData.noY$A &lt;- 1 ObsData$Pred.Y1 &lt;- predict(fit.sl, newdata = ObsData.noY, type = &quot;response&quot;)$pred ## Warning in predict.lm(object, newdata, se.fit, scale = 1, type = if (type == : ## prediction from a rank-deficient fit may be misleading summary(ObsData$Pred.Y1) ## V1 ## Min. :-28.56 ## 1st Qu.: 18.66 ## Median : 23.26 ## Mean : 22.77 ## 3rd Qu.: 27.06 ## Max. : 65.29 3.4.2 Extract outcome prediction as if everyone is untreated ObsData.noY$A &lt;- 0 ObsData$Pred.Y0 &lt;- predict(fit.sl, newdata = ObsData.noY, type = &quot;response&quot;)$pred ## Warning in predict.lm(object, newdata, se.fit, scale = 1, type = if (type == : ## prediction from a rank-deficient fit may be misleading summary(ObsData$Pred.Y0) ## V1 ## Min. :-30.40 ## 1st Qu.: 16.64 ## Median : 21.34 ## Mean : 20.82 ## 3rd Qu.: 25.12 ## Max. : 61.35 3.4.3 Treatment effect estimate ObsData$Pred.TE &lt;- ObsData$Pred.Y1 - ObsData$Pred.Y0 Mean value of predicted treatment effect summary(ObsData$Pred.TE) ## V1 ## Min. :0.7452 ## 1st Qu.:1.8589 ## Median :1.9551 ## Mean :1.9542 ## 3rd Qu.:2.0524 ## Max. :4.2089 3.4.4 Additional details for SL other similar algorithms such as cross-fitting had been shown to have better performances for rare outcomes, consider using stratification to attempt to maintain training and test sample ratios the same if data is clustered and not independent and identically distributed, use ID for the cluster "]]
